% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classes.R
\name{odemodel}
\alias{odemodel}
\title{Generate model objects for use in Xs (models with sensitivities)}
\usage{
odemodel(
  f,
  deriv = TRUE,
  deriv2 = FALSE,
  forcings = NULL,
  events = NULL,
  outputs = NULL,
  fixed = NULL,
  estimate = NULL,
  modelname = "odemodel",
  solver = c("deSolve", "Sundials", "boost"),
  gridpoints = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{f}{Something that can be converted to \link{eqnvec}, e.g. a named character vector
specifying the right-hand sides of the ODE system.}

\item{deriv}{Logical. If \code{TRUE}, generate first-order sensitivities.
Defaults to \code{TRUE}.}

\item{deriv2}{Logical. If \code{TRUE}, generate second-order sensitivities.
Only available with the \code{"boost"} solver and requires \code{deriv = TRUE}.}

\item{forcings}{Character vector with the names of external forcings.}

\item{events}{\code{data.frame} specifying discrete events during integration.
Must contain the columns \code{"var"} (character, name of the affected state),
\code{"time"} (character or numeric, time point),
\code{"value"} (character or numeric, value to apply), and
\code{"method"} (character, either \code{"replace"} or \code{"add"}).
Events must be defined here if they depend on parameters (e.g., event time or value).
If both \code{time} and \code{value} are purely numeric, such events may alternatively
be specified in \code{\link[=Xs]{Xs()}}, but this is only supported for
\code{solver = "deSolve"}.
See \link[deSolve:events]{events} for details on the \code{deSolve} implementation, or
\code{\link[CppODE:CppODE]{CppODE::CppODE()}} for information on event handling in the \code{boost} solver.}

\item{outputs}{Named character vector for additional output variables.}

\item{fixed}{Character vector with the names of parameters (initial values and dynamic)
for which no sensitivities are required (this speeds up integration).}

\item{estimate}{Character vector specifying parameters (initial values and dynamic)
for which sensitivities are returned. If specified, \code{estimate} overwrites \code{fixed}.}

\item{modelname}{Character. The base name of the generated C/C++ file.}

\item{solver}{Character string specifying the solver backend.
One of \code{"deSolve"}, \code{"Sundials"} (deprecated), or \code{"boost"}.}

\item{gridpoints}{Integer specifying the minimum number of internal time points
where the ODE is evaluated.}

\item{verbose}{Logical. If \code{TRUE}, print compiler output to the R console.}

\item{...}{Additional arguments passed to \code{\link[cOde:funC]{cOde::funC()}} or
\code{\link[CppODE:CppODE]{CppODE::CppODE()}}.}
}
\value{
A list containing the generated model objects.
For \code{solver = "deSolve"}, the list includes \code{func} (ODE object)
and optionally \code{extended} (ODE + sensitivities object).
For \code{solver = "boost"}, the list contains compiled C++ solvers:
\code{boostODE}, \code{boostODE_sens}, and (if requested) \code{boostODE_sens2}.
}
\description{
Creates and compiles model objects for systems of ordinary differential equations (ODEs)
with optional first- and second-order sensitivities. Depending on the selected solver,
the function interfaces either to \code{\link[cOde:funC]{cOde::funC()}} (for \code{solver = "deSolve"})
or to \code{\link[CppODE:CppODE]{CppODE::CppODE()}} (for \code{solver = "boost"}).
}
\examples{

\dontrun{

## Generate a compiled ODE model from an equation vector
## The model will not return sensitivities for "switch"
## Files will be generated in your working directory!

f <- eqnvec(A = "-k*A + switch*F")
model <- odemodel(f, forcings = "F", fixed = "switch")
print(model)

## Generate the same model from an equation list
f <- addReaction(NULL, from = "", to = "A", rate = "switch*F", description = "production")
f <- addReaction(f   , from = "A", to = "", rate = "k*A", description = "degradation")
print(f)

model <- odemodel(f, forcings = "F", fixed = "switch")
print(model)


# create forcings
forc1 <- data.frame(name = "F", time = seq(0,5, 0.1), value = sin(seq(0,5,0.1)))
forc2 <- data.frame(name = "F", time = seq(0,5, 0.1), value = exp(-seq(0,5,0.1)))
forc3 <- data.frame(name = "F", time= 0,              value = 0.1)


x <- Xs(model, forc1, condition = "forc1") + 
  Xs(model, forc2, condition = "forc2") + 
  Xs(model, forc3, condition = "forc3")

g <- Y(c(out1 = "F * A", out2 = "F"), x)

times <-  seq(0,5, 0.001)
pars <- setNames(runif(length(getParameters(x))), getParameters(x))

pred <- (g*x)(times, pars)  
plot(pred)


}
}
\seealso{
\code{\link[cOde:funC]{cOde::funC()}}, \code{\link[CppODE:CppODE]{CppODE::CppODE()}}
}
