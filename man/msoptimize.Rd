% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize.R
\name{msoptimize}
\alias{msoptimize}
\title{Perform Multi-Start Optimization using Various Sampling Methods}
\usage{
msoptimize(
  obj,
  center,
  fits = 20,
  cores = 1,
  method = "L-BFGS-B",
  lower = -Inf,
  upper = Inf,
  control = list(),
  samplefun = stats::rnorm,
  seed = NULL,
  start1stfromCenter = TRUE,
  ...
)
}
\arguments{
\item{obj}{Object of class obsfn, i.e. a function obj(..., fixed, deriv, conditions, env) that returns an objective list, objlist.}

\item{center}{Parameter values around which the initial values for each fit are randomly sampled.
The initial values are the sum of center and the output of samplefun.}

\item{fits}{The number of optimization runs to perform. Defaults to 20.}

\item{cores}{The number of cores to use for parallel processing. Defaults to 1.}

\item{method}{A character string specifying the optimization method. Defaults to "L-BFGS-B".}

\item{lower}{A numeric vector of lower bounds for the parameters. Defaults to `-Inf`.}

\item{upper}{A numeric vector of upper bounds for the parameters. Defaults to `Inf`.}

\item{control}{A list of control parameters to pass to the optimization algorithm.}

\item{samplefun}{Function to sample random initial values. It is assumed that samplefun has 
a named parameter "n" which defines how many random numbers are to be returned, 
such as for rnorm or runif. By default rnorm is used.}

\item{seed}{A seed for the random number generator. If NULL, no seed is set.}

\item{start1stfromCenter}{Logical, if TRUE the first optimization starts from the center without adding random values.}

\item{...}{Additional arguments to pass to the objective function or to samplefun.}
}
\value{
A list where each element contains the result of an individual optimization run.
        Each element has the same structure as the return value of the `optimize` function.
}
\description{
This function conducts multiple optimization runs starting from different points
generated using customizable sampling functions. It's useful for finding global optima 
in complex objective functions that may have multiple local minima.
}
