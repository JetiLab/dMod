% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prediction.R
\name{Y}
\alias{Y}
\title{Observation functions.}
\usage{
Y(
  g,
  f = NULL,
  states = NULL,
  parameters = NULL,
  condition = NULL,
  attach.input = TRUE,
  deriv = TRUE,
  deriv2 = FALSE,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE
)
}
\arguments{
\item{g}{Named character vector or \link{eqnvec} defining the observation function.}

\item{f}{Named character vector of equations or an object that can be converted
to \link{eqnvec}, or an object of class 'fn'. If \code{f} is provided, states and parameters
are automatically inferred from \code{f}.}

\item{states}{Character vector, alternative definition of state variables, usually
the names of \code{f}. If both \code{f} and \code{states} are provided, the \code{states} argument
overrides those derived from \code{f}.}

\item{parameters}{Character vector, alternative definition of parameters, usually
the symbols contained in \code{g} and \code{f} except for \code{states} and the keyword \code{time}.
If both \code{f} and \code{parameters} are provided, the \code{parameters} argument overrides those
derived from \code{f} and \code{g}.}

\item{condition}{Either \code{NULL} (generic prediction for any condition) or a character
string specifying the condition for which the function generates predictions.}

\item{attach.input}{Logical, indicating whether the original model input should be
included in the output.}

\item{deriv}{Logical, if \code{TRUE}, the function evaluates first-order derivatives
of observables with respect to parameters.}

\item{deriv2}{Logical, if \code{TRUE}, the function also evaluates second derivatives
of observables with respect to parameters.}

\item{compile}{Logical, if \code{TRUE}, the function is compiled (see \link[CppODE:funCpp]{CppODE::funCpp}).}

\item{modelname}{Character, used if \code{compile = TRUE}, specifies a fixed filename
for the generated C file.}

\item{verbose}{Logical, print compiler output to the R console.}
}
\value{
An object of class \link{obsfn}, i.e. a function
\code{g(..., deriv = TRUE, deriv2 = FALSE, condition = NULL, verbose = F)} representing the evaluation of the
observation function. The function returns observable values and, if requested,
their first- and second-order derivatives with respect to the parameters.
}
\description{
Creates an object of type \link{obsfn} that evaluates an observation function
and, if requested, its first and second derivatives based on the output of a model
prediction function, see \link{prdfn}, as e.g. produced by \link{Xs}.
}
\examples{
\dontrun{
  # Define a time grid on which to make a prediction by peace-wise linear function.
  # Then define a (generic) prediction function based on thid grid.
  times <- 0:5
  grid <- data.frame(name = "A", time = times, row.names = paste0("p", times))
  x <- Xd(grid)
  
  # Define an observable and an observation function
  observables <- eqnvec(Aobs = "s*A")
  g <- Y(g = observables, f = NULL, states = "A", parameters = "s")
  
  # Collect parameters and define an overarching parameter transformation
  # for two "experimental condtions".
  dynpars <- attr(x, "parameters")
  obspars <- attr(g, "parameters")
  innerpars <- c(dynpars, obspars)
  
  trafo <- structure(innerpars, names = innerpars)
  trafo_C1 <- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
  trafo_C2 <- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)
  
  p <- NULL
  p <- p + P(trafo = trafo_C1, condition = "C1")
  p <- p + P(trafo = trafo_C2, condition = "C2")
  
  # Collect outer (overarching) parameters and 
  # initialize with random values
  outerpars <- attr(p, "parameters")
  pars <- structure(runif(length(outerpars), 0, 1), names = outerpars)
  
  # Predict internal/unobserved states
  out1 <- (x*p)(times, pars)
  plot(out1)
  
  # Predict observed states in addition to unobserved
  out2 <- (g*x*p)(times, pars)
  plot(out2)
}
}
