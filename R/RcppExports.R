# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Non-linear log likelihood for the ALOQ part (C++ implementation)
#'
#' @param nout DataFrame from res/res_cpp, must contain:
#'   - weighted.residual (numeric) : wr (unscaled)
#'   - weighted.0       (numeric) : w0 (unscaled)
#'   - sigma            (numeric) : s
#' @param derivs NumericMatrix of first derivatives of prediction (NOT wr),
#'   with columns corresponding to parameters only (no time/name columns).
#' @param derivs_err NumericMatrix of first derivatives of sigma,
#'   same dimension as derivs (n_data × n_pars) or NULL.
#' @param opt_BLOQ Character scalar, e.g. "M3", "M4NM", "M4BEAL", "M1".
#'   Only "M4BEAL" changes the ALOQ contribution (extra Phi(w0) term).
#' @param opt_hessian Named LogicalVector controlling Hessian components
#'   ("ALOQ_part1", "ALOQ_part2", "ALOQ_part3") when 2nd derivatives are NOT supplied.
#' @param bessel_correction Numeric scalar. If != 1, weighted residuals
#'   and w0 are multiplied by this factor (Bessel correction) for the
#'   optimization objective. The TRUE ML (-2logL without Bessel) is stored
#'   in the "neg2ll" attribute.
#' @param deriv2 Optional 3D array (NumericVector with dim attribute)
#'   of second derivatives of prediction: dim = c(n_data, n_pars, n_pars).
#' @param deriv2_err Optional 3D array of second derivatives of sigma,
#'   same dims as deriv2.
#'
#' @details
#' If deriv2 is NULL, the Hessian is computed using the same first-order
#' approximation as in the original R implementation, controlled by opt_hessian,
#' including the approximate M4BEAL Hessian block.
#'
#' If deriv2 is NOT NULL, a full exact Hessian for the Gaussian ALOQ part
#' and for the M4BEAL ALOQ contribution is computed using the 2nd derivatives.
#' In that case, opt_hessian is ignored.
#'
#' @return List with elements:
#'   - value    : corrected negative log-likelihood (for optimization)
#'   - gradient : numeric vector (or NULL) w.r.t parameters
#'   - hessian  : numeric matrix (or NULL)
#'   Attributes:
#'   - "chisquare"       : TRUE chisquare (no Bessel correction)
#'   - "neg2ll"          : TRUE -2*log(L) (no Bessel, but with M4BEAL term if used)
#'   - "besselcorrected" : logical
#'
#' @export
nll_ALOQ_cpp <- function(nout, derivs = NULL, derivs_err = NULL, opt_BLOQ = "M3", opt_hessian = logicalVector(), bessel_correction = 1.0, deriv2 = NULL, deriv2_err = NULL) {
    .Call(`_dMod_nll_ALOQ_cpp`, nout, derivs, derivs_err, opt_BLOQ, opt_hessian, bessel_correction, deriv2, deriv2_err)
}

#' Non-linear log likelihood for the BLOQ part (C++ implementation)
#'
#' @param nout_bloq DataFrame with BLOQ rows from res()/res_cpp, must contain:
#'   - value             (numeric) : original DV (for LLOQ check in M4)
#'   - weighted.residual (numeric) : wr
#'   - weighted.0        (numeric) : w0
#'   - sigma             (numeric) : s
#' @param derivs_bloq NumericMatrix of first derivatives of prediction,
#'   dimension n_data × n_pars, only parameter columns (no time/name).
#' @param derivs_err_bloq NumericMatrix of first derivatives of sigma,
#'   same dimension as derivs_bloq, or NULL.
#' @param opt_BLOQ Character scalar, one of "M3","M4NM","M4BEAL","M1".
#' @param opt_hessian Named LogicalVector controlling Hessian pieces
#'   ("BLOQ_part1","BLOQ_part2","BLOQ_part3").
#'
#' @return An object of class "objlist" (list with value, gradient, hessian).
#' @export
nll_BLOQ_cpp <- function(nout_bloq, derivs_bloq = NULL, derivs_err_bloq = NULL, opt_BLOQ = "M3", opt_hessian = logicalVector()) {
    .Call(`_dMod_nll_BLOQ_cpp`, nout_bloq, derivs_bloq, derivs_err_bloq, opt_BLOQ, opt_hessian)
}

#' Compute residuals (Rcpp implementation, optimized)
#'
#' @param data DataFrame with columns: time, name, value, sigma, lloq
#' @param out NumericMatrix with predictions (first column = time)
#' @param err Nullable NumericMatrix with error model predictions
#' @return List with:
#'   - data: DataFrame with residual columns
#'   - deriv:  NumericMatrix n_data × n_pars (first derivatives of out)
#'   - deriv2: NumericArray  n_data × n_pars × n_pars (second derivatives of out)
#'   - deriv.err:  NumericMatrix n_data × n_pars (first derivatives of err sigma-part)
#'   - deriv2.err: NumericArray  n_data × n_pars × n_pars (second derivatives of err sigma-part)
#' @export
res_cpp <- function(data, out, err = NULL) {
    .Call(`_dMod_res_cpp`, data, out, err)
}

